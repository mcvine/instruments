# -*- Python -*-
#
# Jiao Lin <jiao.lin@gmail.com>
#

import click
from ..cli import instruments
from mcvine.cli import pyre_app, alias

cmd_prefix = "mcvine instruments cncs "

@instruments.group()
@alias("cncs", cmd_prefix)
def cncs():
    return

cncs_app = lambda name: pyre_app(parent=cncs, appname = name, cmd_prefix=cmd_prefix)

# beam sim
@cncs_app('cncs_moderator2sample')
def mod2sample(ctx):
    "moderator to sample simulation"
    from .applications import Moderator2Sample as mod
    return mod.App, mod.__file__

@cncs_app('cncs_config_m2s')
def config_mod2sample(ctx):
    "simplified moderator to sample simulation app"
    from .applications import Config_Moderator2Sample as mod
    return mod.App, mod.__file__

@cncs_app('cncs_beam')
def beam(ctx):
    "beam simulation. include mod2sample sim and post-processing"
    from .applications import Beam as mod
    return mod.App, mod.__file__


# detsys sim
@cncs.command(help="""convert scattereed neutrons to events (pixelID, tofChannelNo, prob)
intercepted by CNCS detector system.""")
@click.argument("neutrons", default="neutrons.dat")
@click.option("--workdir", default='work-cncs-neutrons2events')
@click.option("--nodes", default=0)
@click.option("--ncount", default=0)
@alias("cncs_neutrons2events", "%s neutrons2events" % cmd_prefix)
def neutrons2events(neutrons, workdir, nodes, ncount):
    from .applications.Neutrons2Events import run
    run(neutrons, workdir, nodes, ncount=ncount)
    return
    
@cncs.command(help="""convert events.dat (generated by neutrons2events) to nxs file""")
@click.argument("events", default="events.dat")
@click.argument("nxs", default="cncs-sim.nxs")
@click.option("--tofbinsize", default=0.1)
@click.option("--type", default="processed", type=click.Choice(['processed']))
@click.option("--Ei", default=0., help="nominal incident energy in meV")
@alias("cncs_events2nxs", "%s events2nxs" % cmd_prefix)
def events2nxs(events, nxs, tofbinsize, type, ei):
    from .applications.Events2Nxs import run
    run(events, nxs, tofbinsize=tofbinsize, type=type, Ei=ei)
    return
    
@cncs.command(help="""convert scattereed neutrons to nexus file

Impl.: mcvine.instruments.CNCS.applications.Neutrons2Nxs
""")
@click.option("--neutrons", default="", help='path to neutron data file')
@click.option("--nxs", default="cncs-sim.nxs", help='nexus output path')
@click.option("--workdir", default='work-cncs-neutrons2nxs', help="working dir to save intermediate data fiels")
@click.option("--nodes", default=0)
@click.option("--type", default="processed", type=click.Choice(['processed']))
@click.option("--populate-metadata/--no-populate-metadata", default=False)
@click.option("--beam", default="", help='beam simulation path. need only when populate-metadata is True')
@alias("cncs_neutrons2nxs", "%s neutrons2nxs" % cmd_prefix)
@click.pass_context
def neutrons2nxs(ctx, neutrons, nxs, workdir, nodes, type, populate_metadata, beam):
    if not neutrons:
        click.echo(ctx.get_help(), color=ctx.color)
        return
    from .applications.Neutrons2Nxs import run
    run(neutrons, nxs, type, workdir, nodes)

    if populate_metadata:
        import os, shutil
        # save a copy
        base, ext = os.path.splitext(nxs)
        nometadata = base+"_no_metadata"+ext
        shutil.copyfile(nxs, nometadata)
        # populate
        from .applications import nxs as nxsmod
        beam_out = os.path.abspath(os.path.join(beam, 'out'))
        nxsmod.populate_Ei_data(beam_out, nxs)
    return


# nexus file utilities
@cncs.group()
def nxs():
    "nexus utils"
    return

@nxs.command()
@click.option('--type', default="Ei", type=click.Choice(['Ei']), help='type of metadata')
@click.option('--beam_outdir', help='path to the output directory of cncs beam simulation')
@click.option('--nxs', help='path to the nexus file to be decorated')
@alias("cncs_nxs_populate_metadata", "%s nxs populate_metadata" % cmd_prefix)
@click.pass_context
def populate_metadata(ctx, type, beam_outdir, nxs):
    "populate metadata into the simulated nexus file"
    if not nxs or not beam_outdir:
        click.echo(ctx.get_help(), color=ctx.color)
        return
    from .applications import nxs as nxsmod
    f = getattr(nxsmod, "populate_%s_data" % type)
    f(beam_outdir, nxs)
    return

@nxs.command()
@click.argument("nxs")
@click.option('--out', default="iqe.nxs", help="output path. Eg. iqe.nxs")
@click.option('--use_ei_guess', default=False)
@click.option('--ei_guess', help='guess for Ei', default=0.)
@click.option('--qaxis', help='Qmin Qmax dQ', default=(0.,13.,0.1))
@click.option('--eaxis', help='Emin Emax dE', default=(0.,0.,0.))
@click.option('--tof2E/--no-tof2E', help='If true, input data must be tof events', default=None)
@click.option('--ibnorm',
              help='Incident beam normalization',
              type=click.Choice(['ByCurrent', 'ToMonitor', 'None']),
              default='ByCurrent')
@alias("cncs_nxs_reduce", "%s nxs reduce" % cmd_prefix)
def reduce(nxs, out, use_ei_guess, ei_guess, qaxis, eaxis, tof2e, ibnorm):
    "run reduction"
    if ei_guess > 0:
        use_ei_guess = True
    if tof2e is None:
        tof2e = 'guess'

    qmin, qmax, dq = qaxis
    qaxis = (qmin, dq, qmax)
    
    import numpy as np
    if np.all(np.array(eaxis)==0.): eaxis = None
    if eaxis is not None:
        emin, emax, de = eaxis
        eaxis = emin, de, emax
    
    nxs = nxs.encode("utf8"); out = out.encode("utf8")
    ibnorm = ibnorm.encode("utf8")
    print "* tof2E=%s" % tof2e
    d = dict(
        nxsfile = nxs,
        use_ei_guess = use_ei_guess,
        ei_guess = ei_guess,
        qaxis = qaxis,
        eaxis = eaxis,
        outfile = out,
        tof2E = tof2e,
        ibnorm = ibnorm,
        )
    from .applications.nxs import reduce
    reduce(**d)
    return


# End of file 
